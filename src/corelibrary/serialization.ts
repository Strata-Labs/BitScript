import { TxData } from "./stackstate";
import { ScriptData } from "./scriptdata";
const BN = require('bn.js');
import * as CryptoJS from "crypto-js";

// https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki
// copied/improved from Burak's ScriptWiz: https://github.com/bit-matrix/script-wiz-lib-core/blob/master/src/serialization.ts

// serialization of transaction data
// goal: create a message from transaction data that can be used for ecdsa verification (signature, message, public key)
// message is generated by serializing the transaction, this can be done in three different ways
// legacy serialization is innate, segwit defined in BIP143, & taproot in BIP340

// tools for serialization
export const numToLE64 = (scriptdata: ScriptData): ScriptData => {
  const inputByteLength = scriptdata.dataBytes.length;
  if (inputByteLength > 8) throw "Input byte length must be maximum 8 byte";

  const isNegate = scriptdata.dataBinary[0] === "1";
  let input = new BN(scriptdata.dataBinary, 2);

  if (!isNegate) {
    const input64 = input.toString(2, 64);
    return ScriptData.fromBinaryString(input64);
  } else {
    if (scriptdata.dataNumber !== undefined) input = new BN(scriptdata.dataNumber);

    const negateValue = input.abs().neg();
    const twosNegateValue = negateValue.toTwos(64);
    const twosNegateValue64 = twosNegateValue.toString(2, 64);

    return ScriptData.fromBinaryString(twosNegateValue64);
  }
}

export const numToLE32 = (scriptdata: ScriptData): ScriptData => {
  const inputByteLength = scriptdata.dataBytes.length;
  if (inputByteLength > 4) throw "Input byte length must be maximum 4 byte";

  const isNegate = scriptdata.dataBinary[0] === "1";
  let input = new BN(scriptdata.dataBinary, 2);

  if (!isNegate) {
    const input32 = input.toString(2, 32);
    return ScriptData.fromBinaryString(input32);
  } else {
    if (scriptdata.dataNumber !== undefined) input = new BN(scriptdata.dataNumber);

    const negateValue = input.abs().neg();
    const twosNegateValue = negateValue.toTwos(32);
    const twosNegateValue32 = twosNegateValue.toString(2, 32);

    return ScriptData.fromBinaryString(twosNegateValue32);
  }
};

export const hexLE = (hex: string): string => bytesToHex(hexToBytes(hex).reverse());

export const bytesToHex = (bytes: Uint8Array): string => bytes.reduce((hexString, currentByte) => hexString + byteToHex(currentByte), "");

const byteToHex = (byte: number): string => {
  if (!validByte(byte)) throw "byteToHex: invalid byte number";
  return byte.toString(16).padStart(2, "0");
};

const validByte = (byte: number): boolean => 0 <= byte && byte <= 255;

const hexToByte = (hex: string): number => {
  if (!validHex(hex)) throw "hexToByte: invalid hex string";
  return parseInt(hex, 16);
};

export const hexToBytes = (hex: string): Uint8Array => Uint8Array.from(hexToHexBytes(hex).map((byte) => hexToByte(byte)));

const validHex = (hex: string) => hex.length % 2 === 0 && !/[^a-fA-F0-9]/u.test(hex);

const hexToHexBytes = (hex: string): string[] => {
  if (!validHex(hex)) throw "hexToHexBytes: invalid hex string";
  const matches: RegExpMatchArray | null = hex.match(/.{1,2}/g);
  if (matches === null) return [];
  return matches.map((match: string) => match);
};

export const size = (scriptdata: ScriptData): ScriptData => {
  const numberValue = scriptdata.dataHex.length / 2;
  return ScriptData.fromNumber(numberValue);
};
  

// SegWit Serialization -> Message (BIP143 transaction digest algorithm)
// Double SHA256 of the serialization of:
// 1. nVersion of the transaction (4-byte little endian)
// 2. hashPrevouts (32-byte hash)
// 3. hashSequence (32-byte hash)
// 4. outpoint (32-byte hash + 4-byte little endian)
// 5. scriptCode of the input (serialized as scripts inside CTxOuts)
// 6. value of the output spent by this input (8-byte little endian)
// 7. nSequence of the input (4-byte little endian)
// 8. hashOutputs (32-byte hash)
// 9. nLocktime of the transaction (4-byte little endian)
// 10. sighash type of the signature (4-byte little endian)

export const segwitSerialization = (data: TxData) => {
    const currentInput = data.inputs[data.currentInputIndex];

    if (currentInput.scriptSig === "" || currentInput.vout === "" || currentInput.amount === "" || data.timelock === "" || data.version === "" || currentInput.previousTxId === "" || currentInput.sequence === "") {
        throw "Incorrect transaction data - likely empty";
    }

    // Prep data for serialization
    const scriptSigHex = ScriptData.fromHex(currentInput.scriptSig).dataHex;
    const vOut = numToLE32(ScriptData.fromHex(currentInput.vout)).dataHex;
    const inputAmount = numToLE64(ScriptData.fromNumber(Number(currentInput.amount) * 100000000)).dataHex;
    const timelock = numToLE32(ScriptData.fromNumber(Number(data.timelock))).dataHex;
    const scriptCode = ScriptData.fromHex(scriptSigHex.toString());
    
    // 1. nVersion of the transaction (4-byte little endian)
    const version = numToLE32(ScriptData.fromNumber(Number(data.version))).dataHex;
    
    // 2. hashPrevouts (32-byte hash) -> All input outpoints (txid + index) concatenated & hash256; aka a hash of all needed UTXOs
    let hashPrevouts = "";
    data.inputs.forEach((input) => {
      if (input.previousTxId === "" || input.vout === "") throw "Previous TX ID and Vout must not be empty in transaction template";
      // vout is 4 bytes in little endian
      const vout = numToLE32(ScriptData.fromNumber(Number(input.vout))).dataHex;
      hashPrevouts += ScriptData.fromHex(hexLE(input.previousTxId) + vout).dataHex;
    })
    let hash256Prevouts = CryptoJS.SHA256(CryptoJS.SHA256(hashPrevouts)).toString();
   
    // 3. hashSequence (32-byte hash) -> All input sequences concatenated & hash256; aka a hash of all input sequences
    let hashSequence = "";
    if (currentInput.sequence === "") {
      throw "Sequence must not be empty in transaction template"
    } else {
      hashSequence = currentInput.sequence;
    }
    const nsequence = hexLE(currentInput.sequence);
    hashSequence = CryptoJS.SHA256(CryptoJS.SHA256(nsequence)).toString();
  
    // 4. outpoint (32-byte hash + 4-byte little endian)
    if (currentInput.previousTxId === "") throw "Previous TX ID and Vout must not be empty in transaction template";
    const outpoint = hexLE(currentInput.previousTxId) + vOut;
  
    // 5. script code hash
    const scriptCodeSize = size(scriptCode).dataHex.substring(0, 2);
  
    // 8. hashOutputs
    let hashOutputs = "";
    data.outputs.forEach((output) => {
      if (output.amount === "" || output.scriptPubKey === "") throw "Output amount and scriptPubKey must not be empty in transaction template";
      const amount = numToLE64(ScriptData.fromNumber(Number(output.amount) * 100000000)).dataHex;
      const scriptSize = size(ScriptData.fromHex(output.scriptPubKey));
      const scriptPubKey = ScriptData.fromHex(output.scriptPubKey).dataHex;
      hashOutputs += amount.toString() + scriptSize + scriptPubKey;
    })
  
    return version + hashPrevouts + hashSequence + outpoint + scriptCodeSize + scriptCode.dataHex + inputAmount + nsequence + hashOutputs + timelock + "01000000";
  };